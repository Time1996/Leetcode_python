# Leetcode 861 翻转矩阵后的得分
***
### 题目描述
有一个二维矩阵`A`其中每个元素的值为`0`或`1`。  

移动是指选择任一行或列，并转换该行或列中的每一个值：将所有的`0`都改为`1`，将所有`1`都改为`0`。  

在作出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。  

返回尽可能高的分数。


**示例:**   
	
	输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
	输出：39
	解释：
	转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
	0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
	
    	
**提示：**  

* `1 <= A.length <= 20`
* `1 <= A[0].length <= 20`
* `A[i][j]`是`0`或`1`
	

### 考点

* 贪心算法

### 思路   
贪心计算，把第一列全设为1，后面的每一列1的个数至少多于0的个数。


### 代码  
执行用时: **52ms**, 内存消耗: **12.8MB** 

```
class Solution:
    def matrixScore(self, A: List[List[int]]) -> int:
        row, col = len(A), len(A[0])
        # 第0列全部变为1
        ret = (1 << (col - 1)) * row
        for i in range(1, col):
            count1 = 0
            # 统计第 j 列 1的个数（跟第0列相同元素的个数）
            for j in range(row):
                if A[j][i] == A[j][0]:
                    count1 += 1
            # 如果1的个数少于0的个数就翻转
            count1 = count1 if count1 * 2 > row else row - count1
            ret += (1 << (col - 1 - i)) * count1
        return ret                 
```








	
