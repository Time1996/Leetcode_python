# Leetcode 801 使序列递增的最小交换次数
***
### 题目描述
我们有两个长度相等且不为空的整型数组 `A` 和 `B` 。

我们可以交换 `A[i]` 和 `B[i]` 的元素。注意这两个元素在各自的序列中应该处于相同的位置。

在交换过一些元素之后，数组 `A` 和 `B` 都应该是严格递增的（数组严格递增的条件仅为`A[0] < A[1] < A[2] < ... < A[A.length - 1]）`。

给定数组 `A` 和 `B` ，请返回使得两个数组均保持严格递增状态的最小交换次数。假设给定的输入总是有效的。


**示例1：**   
	
	示例:
	输入: A = [1,3,5,4], B = [1,2,3,7]
	输出: 1
	解释: 
	交换 A[3] 和 B[3] 后，两个数组如下:
	A = [1, 3, 5, 7] ， B = [1, 2, 3, 4]
	两个数组均为严格递增的。

    	
**注意：**  

* `A, B`两个数组的长度总是相等，且长度的范围为`[1, 1000]`。
* `A[i], B[1]`均为`[0, 2000]`区间内的整数。
	

### 考点

* 动态规划

### 思路
本题在考虑第i位置是否要交换时需要考虑i-1位置是否需要交换，（eg:A=[0,4,4,5,9],B=[0,1,6,8,10],当i=2时，最优做法是交换i=1位置上A和B的元素）。  
swap[i]表示交换A、B的第i位，noSwap[i]表示不交换。因为循环从1开始，第0位交换A和B的元素，swap[0]=1，不交换，noSwap[0]=0。  

* 遍历数组，分别用swap[i]、noSwap[i]记录，截止到第i位最小交换次数。
* 如果在第i位A和B数组满足递增关系则noSwap[i] = noSwap[i-1], swap[i] = swap[i-1] + 1。
* 如果满足关系A[i] > B[i-1]且B[i] > A[i-1] 存在两种情形：1)A和B满足递增关系：则这里交换与否取决于i-1位置已经交换过的次数和没有交换过的次数。如果i-1位置交换过，且累计到目前的次数为n,但是i-1位置没有交换过，且累计到目前的次数为n-1，则此时会选择i-1位没有交换过的次数。即：noSwap[i] = min(noSwap[i-1], swap[i-1]), swap[i] = min(swap[i-1], noSwap[i-1])+1；2)如果A和B不满足递增关系：如果不交换i位置的数，不符合递增规律，因此需要交换前一个位置的数，即：noSwap[i] = swap[i-1]；因为不符合递增规律的话，也只有A[i] > B[i-1]且B[i] > A[i-1]这一种情况，如果交换i位置的两个数，不会对前一个位置的数造成影响，即：swap[i] = noSwap[i-1] + 1。此两种情况可以合二为一：noSwap[i] = min(noSwap[i], swap[i-1]), swap[i] = min(swap[i], noSwap[i-1])+1。


### 代码  
执行用时: **68ms**, 内存消耗: **13.1MB** 

```
class Solution:
    def minSwap(self, A: List[int], B: List[int]) -> int:
        swap = [1000] * len(A)
        noSwap = [1000] * len(A)
        swap[0] = 1
        noSwap[0] = 0
        for i in range(1, len(A)):
            if A[i] > A[i-1] and B[i] > B[i-1]:
                noSwap[i] = noSwap[i-1]
                swap[i] = swap[i-1] + 1
            if A[i] > B[i-1] and B[i] > A[i-1]:
                noSwap[i] = min(noSwap[i], swap[i-1])
                swap[i] = min(swap[i], noSwap[i-1]) + 1
        return min(swap[-1], noSwap[-1])
```









	