# Leetcode 915 分割数组
***
### 题目描述

给定一个数组 `A`，将其划分为两个不相交（没有公共元素）的连续子数组 `left` 和 `right`， 使得：

* `left` 中的每个元素都小于或等于 `right` 中的每个元素。
* `left` 和 `right` 都是非空的。
* `left` 要尽可能小。

在完成这样的分组后返回 `left` 的**长度**。可以保证存在这样的划分方法。

**示例1:**

	输入：[5,0,3,8,6]
	输出：3
	解释：left = [5,0,3]，right = [8,6]
	
**示例2:**

	输入：[1,1,1,0,6,12]
	输出：4
	解释：left = [1,1,1,0]，right = [6,12]


**提示：**

1. `2 <= A.length <= 30000`
2. `0 <= A[i] <= 10^6`
3. 可以保证至少有一种方法能够按题目所描述的那样对 `A` 进行划分


### 考点

数组


### 思路

该题需要左边的元素均小于等于右边的元素，所以重点是找到两个数组的分界点，只要左边数组的最大值元素小于右边所有数组元素即可，因此从左至右遍历整个数组，创建两个变量保存左数组的最大值和当前遍历过所有数组的最大值，如果当前遍历元素小于左边数组的最大值，则表示该元素以及之前所有元素属于左边数组，将分界点移至当前元素，并将此元素之前所有元素的最大值赋给左数组最大值，直至遍历结束.


### 代码1
执行用时: **256ms**, 内存消耗: **17.8MB**

```
class Solution:
    def partitionDisjoint(self, A: List[int]) -> int:
        leftMax = A[0]
        globMax = A[0]
        index = 0
        for i, x in enumerate(A):
            globMax = max(globMax, x)
            if x < leftMax:
                leftMax = globMax
                index = i
        return index + 1
```


