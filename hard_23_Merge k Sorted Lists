problem:
      Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
      
Example:

Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6


Solution1:
    '''
    heappush(heap, x)       将 x 入堆
    heappop(heap)           将堆属性中的最小元素弹出   
    heapify(heap)           将 heap 属性强制应用到任意一个列表
    heapreplace(heap, x)    将堆中的最小的元素弹出，同时将 x 入堆
    merge()                 多个堆合并         
    nlargest(n, iter)       返回 iter 中的第 n 大的元素
    nsmallest(n, iter)      返回 iter 中的第 n 小的元素

    将所有链表的节点 push 到堆中，每次把最小的 pop 出来
    '''
    import heapq
    class Solution(object):
    def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """
        heap = []
        for node in lists:
            while node:
                heapq.heappush(heap, node.val)
                node = node.next

        temp = ListNode(-1)
        head = temp

        while heap:
            smallestNodeVal = heapq.heappop(heap)
            temp.next = ListNode(smallestNodeVal)
            temp = temp.next

        return head.next
        
Solution2:
      '''
      class Solution:
      def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """
        a = []
        for i in range(len(lists)):
            while lists[i]:
                a.append(lists[i].val)
                lists[i] = lists[i].next
        a.sort()        
        return a
        '''
Mine:
    
     class Solution:
      def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """
        nums = len(lists)
        Heads = [ListNode(0) for i in range(nums)]
        Heads[0] = lists[0]
        c = 0
        s = Heads[c+1]
        for i in range(1, nums):
            p = Heads[c]
            q = lists[i]
            while p and q:
                if p.val <= q.val:
                    s.next = p
                    p = p.next
                else:
                    s.next = q
                    q = q.next
                s = s.next
            if p:
                s.next = p
            if q:
                s.next = q
            Heads[c+1] = Heads[c+1].next
            c = c + 1
        return Heads[-1]
