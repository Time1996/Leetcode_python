# Leetcode 518 零钱兑换II
***
### 题目描述

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

**示例1：**

	输入: amount = 5, coins = [1, 2, 5]
	输出: 4
	解释: 有四种方式可以凑成总金额:
	5=5
	5=2+2+1
	5=2+1+1+1
	5=1+1+1+1+1

**示例2：**

	输入: amount = 3, coins = [2]
	输出: 0
	解释: 只用面额2的硬币不能凑成总金额3。

**示例3：**

	输入: amount = 10, coins = [10] 
	输出: 1

**注意：**

* 0 <= amount (总金额) <= 5000
* 1 <= coin (硬币面额) <= 5000
* 硬币种类不超过 500 种
* 结果符合 32 位符号整数

### 考点

动态规划


### 思路

尝试了一下DFS会超时。那就只能动态规划了。  
建立`dp`数组，`dp[i]`表示总金额为`i`时有多少种组合数。初始化`dp[0]`为1。  
遍历硬币，对于每种硬币，总金额`i+coin`的组合数等于总金额为`i`的组合数加上`coin`的面值。

### 代码
执行用时: **212ms**, 内存消耗: **13MB**

```
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [0] * (amount + 1)
        dp[0] = 1
        for coin in coins:
            for i in range(amount + 1 - coin):
                if dp[i] != 0:
                    dp[coin + i] += dp[i]
        return dp[-1]
```


