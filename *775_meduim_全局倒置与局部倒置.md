# Leetcode 775 全局倒置与局部倒置
***
### 题目描述
数组`A`是`[0, 1, ..., N - 1]`的一种排列，`N`是数组`A`的长度。全局倒置指的是`i,j`满足`0 <= i < j < N`并且`A[i] > A[j]`，局部倒置指的是`i`满足`0 <= i < N`并且`A[i] > A[i+1]`。  

当数组`A`中全局倒置的数量等于局部倒置的数量时，返回`True`。

**示例1:**   
	
	输入: A = [1,0,2]
	输出: true
	解释: 有 1 个全局倒置，和 1 个局部倒置。

**示例1:**   
	
	输入: A = [1,2,0]
	输出: false
	解释: 有 2 个全局倒置，和 1 个局部倒置
	
**提示**

* `A`是`[0, 1, ..., A.length - 1]`的一种排列。
* `A`的长度在`[1, 5000]`之间。
* 这个问题的时间限制已经减少了。

### 考点

* 技巧

### 思路
这道题如果用暴力解法的话会超出时间限制，需要利用技巧来解答。  
先将所有数从小到大顺序排列  全局=局部=0，计算位置的数字（顺序排列的索引值）与当前索引值的关系，对当前关注的位置，检验当前数字的移位是否造成了不等：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果只是相差1则可理解为这个数字与左或者右的一位相邻数字交换，全局和局部至少+1，局部（必然=）全局  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果相差大于等于2理解为这个数字偏移了至少2位，意味着右边至少有两个比自己小的数（或者左边必然有来2个比自己大且不相邻的数，其中至少一个不相邻）局部（必然<）全局所以造成一定不等。

### 代码  
执行用时 **104ms**, 内存消耗 **13.4MB**

```
class Solution:
    def isIdealPermutation(self, A: List[int]) -> bool:
        for i in range(len(A)):
            if abs(A[i] - i) > 1:
                return False
        return True       
```






	