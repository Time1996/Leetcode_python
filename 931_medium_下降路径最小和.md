# Leetcode 931 下降路径最小和
***
### 题目描述

给定一个**方形**整数数组 `A`，我们想要得到通过 `A` 的下降路径的**最小**和。

下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。



**示例1:**

	输入：[[1,2,3],[4,5,6],[7,8,9]]
	输出：12
	解释：
	可能的下降路径有：
	[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]
	[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]
	[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]
	和最小的下降路径是 [1,4,7]，所以答案是 12。


**提示：**

1. `1 <= A.length == A[0].length <= 100`
2. `-100 <= A[i][j] <= 100`


### 考点

动态规划


### 代码
执行用时: **160ms**, 内存消耗: **14.7MB**

```
class Solution:
    def minFallingPathSum(self, A: List[List[int]]) -> int:
        for i in range(len(A)-2, -1, -1):
            for j in range(len(A)):
                if j == 0:
                    A[i][0] += min(A[i+1][0], A[i+1][1])
                elif j == len(A) - 1:
                    A[i][j] += min(A[i+1][j-1], A[i+1][j])
                else:
                    A[i][j] += min(A[i+1][j-1], A[i+1][j], A[i+1][j+1])
        return min(A[0])
```
