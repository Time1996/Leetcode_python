# Leetcode 769 最多能完成排序的块
***
### 题目描述

数组`arr`是`[0, 1, ..., arr.length - 1]`的一种排列，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。

我们最多能将数组分成多少块？


**示例1:**  

	输入: arr = [4,3,2,1,0]
	输出: 1
	解释:
	将数组分成2块或者更多块，都无法得到所需的结果。
	例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。
	
**示例2:**  

	输入: arr = [1,0,2,3,4]
	输出: 4
	解释:
	我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。
	然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。

	
**注意：**

1. `arr` 的长度在 `[1, 10]` 之间。
2. `arr[i]`是 `[0, 1, ..., arr.length - 1]`的一种排列。

### 考点

数组

### 思路
一个区间内最大的数字，不应该大于这个区间最右边的index。因此我们从左向右遍历，如果已经观测到的最大值小于等于这个区间的index，则可以划分区间。eg: 

```
对于：[1,0,2,3,4]
从左到右遍历：
1       目前最大值1，index = 0， 不可划分
0       目前最大值1，index = 1， 可划分
2       目前最大值2，index = 2， 可划分
3       目前最大值3，index = 3， 可划分
4       目前最大值3，index = 4， 可划分

```

### 代码
执行用时: **44ms**, 内存消耗: **13MB**。

```
class Solution:
    def maxChunksToSorted(self, arr: List[int]) -> int:
        res, max_val = 0, arr[0]
        for i, num in enumerate(arr):
            if num > max_val:
                max_val = num
            if max_val == i:
                res += 1
        return res
```





